#!/usr/bin/env python3
"""
Notification Module
Email, Slack, Teams, Discord, Telegram notifications
"""

import smtplib
import json
import os
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
from typing import List, Dict, Optional
from dataclasses import dataclass
from datetime import datetime
from abc import ABC, abstractmethod

try:
    import requests
    REQUESTS_AVAILABLE = True
except ImportError:
    REQUESTS_AVAILABLE = False


@dataclass
class NotificationConfig:
    """Notification settings"""
    # Email
    email_enabled: bool = False
    smtp_server: str = ""
    smtp_port: int = 587
    smtp_user: str = ""
    smtp_password: str = ""
    sender: str = ""
    recipients: List[str] = None
    use_tls: bool = True
    
    # Slack
    slack_enabled: bool = False
    slack_webhook_url: str = ""
    slack_channel: str = "#infra-alerts"
    
    # Microsoft Teams
    teams_enabled: bool = False
    teams_webhook_url: str = ""
    
    # Discord
    discord_enabled: bool = False
    discord_webhook_url: str = ""
    
    # Telegram
    telegram_enabled: bool = False
    telegram_bot_token: str = ""
    telegram_chat_id: str = ""
    
    # Generic Webhook
    webhook_enabled: bool = False
    webhook_url: str = ""
    webhook_headers: Dict[str, str] = None


class NotificationSender(ABC):
    """Base notification sender class"""
    
    @abstractmethod
    def send(self, title: str, message: str, summary: Dict, attachments: List[str] = None) -> bool:
        pass


class EmailSender(NotificationSender):
    """Email sender"""
    
    def __init__(self, config: NotificationConfig):
        self.config = config
    
    def send(self, title: str, message: str, summary: Dict, attachments: List[str] = None) -> bool:
        if not self.config.email_enabled:
            return False
        
        try:
            msg = MIMEMultipart()
            msg['From'] = self.config.sender
            msg['To'] = ', '.join(self.config.recipients or [])
            msg['Subject'] = title
            
            html_body = self._create_html_body(title, message, summary)
            msg.attach(MIMEText(html_body, 'html', 'utf-8'))
            
            if attachments:
                for filepath in attachments:
                    if os.path.exists(filepath):
                        with open(filepath, 'rb') as f:
                            part = MIMEBase('application', 'octet-stream')
                            part.set_payload(f.read())
                        encoders.encode_base64(part)
                        part.add_header('Content-Disposition', f'attachment; filename="{os.path.basename(filepath)}"')
                        msg.attach(part)
            
            with smtplib.SMTP(self.config.smtp_server, self.config.smtp_port) as server:
                if self.config.use_tls:
                    server.starttls()
                if self.config.smtp_user and self.config.smtp_password:
                    server.login(self.config.smtp_user, self.config.smtp_password)
                server.send_message(msg)
            
            return True
        except Exception as e:
            print(f"Email send failed: {e}")
            return False
    
    def _create_html_body(self, title: str, message: str, summary: Dict) -> str:
        return f"""
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style>
        body {{ font-family: Arial, sans-serif; }}
        .header {{ background: #2c3e50; color: white; padding: 20px; text-align: center; }}
        .summary {{ display: flex; justify-content: space-around; padding: 20px; background: #ecf0f1; }}
        .stat {{ text-align: center; padding: 15px; border-radius: 8px; min-width: 80px; }}
        .ok {{ background: #27ae60; color: white; }}
        .warning {{ background: #f39c12; color: white; }}
        .critical {{ background: #e74c3c; color: white; }}
        .unknown {{ background: #95a5a6; color: white; }}
        .content {{ padding: 20px; }}
        .footer {{ background: #34495e; color: white; padding: 10px; text-align: center; font-size: 12px; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>{title}</h1>
        <p>Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
    </div>
    <div class="summary">
        <div class="stat ok"><h2>{summary.get('ok', 0)}</h2><p>OK</p></div>
        <div class="stat warning"><h2>{summary.get('warning', 0)}</h2><p>Warning</p></div>
        <div class="stat critical"><h2>{summary.get('critical', 0)}</h2><p>Critical</p></div>
        <div class="stat unknown"><h2>{summary.get('unknown', 0)}</h2><p>Unknown</p></div>
    </div>
    <div class="content"><h3>Details</h3><pre>{message}</pre></div>
    <div class="footer"><p>This email was automatically generated by Infrastructure Health Check System.</p></div>
</body>
</html>
"""


class SlackSender(NotificationSender):
    """Slack webhook sender"""
    
    def __init__(self, config: NotificationConfig):
        self.config = config
    
    def send(self, title: str, message: str, summary: Dict, attachments: List[str] = None) -> bool:
        if not self.config.slack_enabled or not REQUESTS_AVAILABLE:
            return False
        
        try:
            blocks = [
                {"type": "header", "text": {"type": "plain_text", "text": f"ðŸ” {title}"}},
                {"type": "divider"},
                {
                    "type": "section",
                    "fields": [
                        {"type": "mrkdwn", "text": f"*Total:*\n{summary.get('total', 0)}"},
                        {"type": "mrkdwn", "text": f"*âœ… OK:*\n{summary.get('ok', 0)}"},
                        {"type": "mrkdwn", "text": f"*âš ï¸ Warning:*\n{summary.get('warning', 0)}"},
                        {"type": "mrkdwn", "text": f"*âŒ Critical:*\n{summary.get('critical', 0)}"}
                    ]
                },
                {"type": "divider"},
                {"type": "context", "elements": [{"type": "mrkdwn", "text": f"ðŸ“… {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"}]}
            ]
            
            if summary.get('warning', 0) > 0 or summary.get('critical', 0) > 0:
                blocks.append({"type": "section", "text": {"type": "mrkdwn", "text": f"```{message[:2000]}```"}})
            
            payload = {"channel": self.config.slack_channel, "blocks": blocks}
            response = requests.post(self.config.slack_webhook_url, json=payload, timeout=10)
            return response.status_code == 200
        except Exception as e:
            print(f"Slack send failed: {e}")
            return False


class TeamsSender(NotificationSender):
    """Microsoft Teams webhook sender"""
    
    def __init__(self, config: NotificationConfig):
        self.config = config
    
    def send(self, title: str, message: str, summary: Dict, attachments: List[str] = None) -> bool:
        if not self.config.teams_enabled or not REQUESTS_AVAILABLE:
            return False
        
        try:
            card = {
                "@type": "MessageCard",
                "@context": "http://schema.org/extensions",
                "themeColor": "FF0000" if summary.get('critical', 0) > 0 else "FFA500" if summary.get('warning', 0) > 0 else "00FF00",
                "summary": title,
                "sections": [{
                    "activityTitle": f"ðŸ” {title}",
                    "activitySubtitle": datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                    "facts": [
                        {"name": "Total", "value": str(summary.get('total', 0))},
                        {"name": "âœ… OK", "value": str(summary.get('ok', 0))},
                        {"name": "âš ï¸ Warning", "value": str(summary.get('warning', 0))},
                        {"name": "âŒ Critical", "value": str(summary.get('critical', 0))}
                    ]
                }]
            }
            
            response = requests.post(self.config.teams_webhook_url, json=card, timeout=10)
            return response.status_code == 200
        except Exception as e:
            print(f"Teams send failed: {e}")
            return False


class DiscordSender(NotificationSender):
    """Discord webhook sender"""
    
    def __init__(self, config: NotificationConfig):
        self.config = config
    
    def send(self, title: str, message: str, summary: Dict, attachments: List[str] = None) -> bool:
        if not self.config.discord_enabled or not REQUESTS_AVAILABLE:
            return False
        
        try:
            color = 0xFF0000 if summary.get('critical', 0) > 0 else 0xFFA500 if summary.get('warning', 0) > 0 else 0x00FF00
            
            embed = {
                "title": f"ðŸ” {title}",
                "color": color,
                "timestamp": datetime.now().isoformat(),
                "fields": [
                    {"name": "Total", "value": str(summary.get('total', 0)), "inline": True},
                    {"name": "âœ… OK", "value": str(summary.get('ok', 0)), "inline": True},
                    {"name": "âš ï¸ Warning", "value": str(summary.get('warning', 0)), "inline": True},
                    {"name": "âŒ Critical", "value": str(summary.get('critical', 0)), "inline": True}
                ],
                "footer": {"text": "Infrastructure Health Check"}
            }
            
            if message:
                embed["description"] = f"```\n{message[:2000]}\n```"
            
            response = requests.post(self.config.discord_webhook_url, json={"embeds": [embed]}, timeout=10)
            return response.status_code in [200, 204]
        except Exception as e:
            print(f"Discord send failed: {e}")
            return False


class TelegramSender(NotificationSender):
    """Telegram bot sender"""
    
    def __init__(self, config: NotificationConfig):
        self.config = config
    
    def send(self, title: str, message: str, summary: Dict, attachments: List[str] = None) -> bool:
        if not self.config.telegram_enabled or not REQUESTS_AVAILABLE:
            return False
        
        try:
            text = f"""
*{title}*

ðŸ“Š *Check Results Summary*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Total: {summary.get('total', 0)}
âœ… OK: {summary.get('ok', 0)}
âš ï¸ Warning: {summary.get('warning', 0)}
âŒ Critical: {summary.get('critical', 0)}
â“ Unknown: {summary.get('unknown', 0)}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ðŸ“… {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
            
            url = f"https://api.telegram.org/bot{self.config.telegram_bot_token}/sendMessage"
            response = requests.post(url, json={
                "chat_id": self.config.telegram_chat_id,
                "text": text,
                "parse_mode": "Markdown"
            }, timeout=10)
            
            return response.status_code == 200
        except Exception as e:
            print(f"Telegram send failed: {e}")
            return False


class WebhookSender(NotificationSender):
    """Generic webhook sender"""
    
    def __init__(self, config: NotificationConfig):
        self.config = config
    
    def send(self, title: str, message: str, summary: Dict, attachments: List[str] = None) -> bool:
        if not self.config.webhook_enabled or not REQUESTS_AVAILABLE:
            return False
        
        try:
            payload = {
                "title": title,
                "message": message,
                "summary": summary,
                "timestamp": datetime.now().isoformat()
            }
            
            headers = self.config.webhook_headers or {'Content-Type': 'application/json'}
            response = requests.post(self.config.webhook_url, json=payload, headers=headers, timeout=10)
            return response.status_code in [200, 201, 202, 204]
        except Exception as e:
            print(f"Webhook send failed: {e}")
            return False


class NotificationManager:
    """Notification manager - manages all notification channels"""
    
    def __init__(self, config: NotificationConfig):
        self.config = config
        self.senders: List[NotificationSender] = []
        
        if config.email_enabled:
            self.senders.append(EmailSender(config))
        if config.slack_enabled:
            self.senders.append(SlackSender(config))
        if config.teams_enabled:
            self.senders.append(TeamsSender(config))
        if config.discord_enabled:
            self.senders.append(DiscordSender(config))
        if config.telegram_enabled:
            self.senders.append(TelegramSender(config))
        if config.webhook_enabled:
            self.senders.append(WebhookSender(config))
    
    def send_all(self, title: str, message: str, summary: Dict, attachments: List[str] = None) -> Dict[str, bool]:
        """Send notifications to all enabled channels"""
        results = {}
        for sender in self.senders:
            sender_name = sender.__class__.__name__
            results[sender_name] = sender.send(title, message, summary, attachments)
        return results
    
    def send_if_issues(self, title: str, message: str, summary: Dict, 
                       attachments: List[str] = None,
                       send_on_warning: bool = True,
                       send_on_critical: bool = True) -> Dict[str, bool]:
        """Send notifications only if there are issues"""
        has_warning = summary.get('warning', 0) > 0
        has_critical = summary.get('critical', 0) > 0
        
        if (send_on_warning and has_warning) or (send_on_critical and has_critical):
            return self.send_all(title, message, summary, attachments)
        
        return {}


if __name__ == "__main__":
    config = NotificationConfig(
        slack_enabled=True,
        slack_webhook_url="https://hooks.slack.com/services/YOUR/WEBHOOK/URL",
        slack_channel="#test"
    )
    
    manager = NotificationManager(config)
    summary = {'total': 30, 'ok': 27, 'warning': 2, 'critical': 1, 'unknown': 0}
    
    results = manager.send_all(
        title="Infrastructure Health Check Report",
        message="Test message",
        summary=summary
    )
    print(f"Send results: {results}")
